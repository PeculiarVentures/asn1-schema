const asn1 = require("asn1js");
import * as defaultConverters from "../converters";

function findParentSchema(target: object): IAsn1Schema | null {
  const parent = (target as any).__proto__;
  if (parent) {
    const schema = Storage.get(parent);
    return schema || findParentSchema(parent);
  }
  return null;
}

function assignSchema(target: any, source: any) {
  Object.assign(target, source);
  target.items = Object.assign({}, target.items, source.items);
}

export function getSchema(target: object): IAsn1Schema | null {
  if (!target) {
    throw new Error("Cannot get schema for current target ");
  }
  return Storage.get(target) || getSchema((target as any).__proto__);
}

export function getAsn1Schema(target: object) {
  const schema = getSchema(target);
  if (schema) {
    if (!schema.schema) {
      schema.schema = createAsn1Schema(target, true);
    }
    return schema;
  }
  throw new Error(`Cannot get ASN1 schema for ${(target as any).name}`);
}

function getSchema2(target: object) {
  if (Storage.has(target)) {
    return Storage.get(target) || null;
  }
  const parentSchema = findParentSchema(target);
  // Initialize default ASN1 schema
  const schema = { type: Asn1TypeType.Sequence, items: {} } as IAsn1Schema;
  if (parentSchema) {
    assignSchema(schema, parentSchema);
  }
  Storage.set(target, schema);

  return schema;
}

function createAsn1Schema(target: object, useNames: boolean) {
  const schema = getSchema(target);
  if (!schema) {
    throw new Error(`Cannot get schema for ${(target as any).name}`);
  }

  const asn1Value = [];
  for (const key in schema.items) {
    const item = schema.items[key];
    const name = useNames ? key : "";
    let asn1Item: any;
    if (typeof (item.type) === "number") {
      // type is Asn1PropType Enum
      const Asn1TypeName = Asn1PropType[item.type];
      const Asn1Type = asn1[Asn1TypeName];
      if (!Asn1Type) {
        throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
      }
      asn1Item = new Asn1Type({ name });
    } else {
      // type is class with schema
      // asn1Item = createAsn1Schema(item.type, schema.type === Asn1TypeType.Choice ? true : false);
      asn1Item = new asn1.Any({ name });
      // asn1Item.name = name;
    }
    const optional = !!item.optional || item.defaultValue !== undefined;
    if (item.repeated) {
      asn1Item.name = "";
      asn1Item = new asn1.Repeated({
        name,
        value: asn1Item,
      });
    }
    if (item.context !== null && item.context !== undefined) {
      // CONTEXT-SPECIFIC
      if (item.implicit) {
        // IMPLICIT
        if (typeof item.type === "number") {
          asn1Value.push(new asn1.Primitive({
            name,
            optional,
            idBlock: {
              tagClass: 3,
              tagNumber: item.context,
            },
          }));
        } else {
            const value = getAsn1Schema(item.type)!.schema.valueBlock.value;
            asn1Value.push(new asn1.Constructed({
              name,
              optional,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context,
              },
              value,
            }));
        }
      } else {
        // EXPLICIT
        asn1Value.push(new asn1.Constructed({
          optional,
          idBlock: {
            tagClass: 3,
            tagNumber: item.context,
          },
          value: [asn1Item],
        }));
      }
    } else {
      // UNIVERSAL
      asn1Item.optional = optional;
      asn1Value.push(asn1Item);
    }
  }

  switch (schema.type) {
    case Asn1TypeType.Sequence:
      return new asn1.Sequence({ value: asn1Value, name: "" });
    case Asn1TypeType.Set:
      return new asn1.Set({ value: asn1Value, name: "" });
    case Asn1TypeType.Choice:
      return new asn1.Choice({ value: asn1Value, name: "" });
    default:
      throw new Error(`Unsupported ASN1 type in use`);
  }
}

export const Asn1Type = (options: IAsn1TypeOptions) => (target: object) => {
  const schema = getSchema2(target);
  Object.assign(schema, options);
};

export const Asn1Prop = (options: IAsn1PropOptions) => (target: object, propertyKey: string) => {
  const schema = getSchema2(target.constructor);
  if (!schema) {
    throw new Error(`Cannot get schema for ${target.constructor.name}`);
  }
  schema.items[propertyKey] = schema.items[propertyKey] || {};

  if (typeof options.type === "number" && !options.converter) {
    // Set default converters
    const converterName = `${Asn1PropType[options.type]}Converter`;
    const defaultConverter = (defaultConverters as any)[converterName] as defaultConverters.IAsn1Converter<any>;
    if (!defaultConverter) {
      throw new Error(`Cannot get '${converterName}' for property '${propertyKey}' of ${target.constructor.name}`);
    }
    options.converter = defaultConverter;
  }

  Object.assign(schema.items[propertyKey], options);
};
